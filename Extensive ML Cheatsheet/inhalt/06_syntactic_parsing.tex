\section{Syntax | Syntactic Parsing}
\subsection*{Description}
\emph{Task} --- Assign syntactic structure, i.e., parse tree, to a sentence by breaking it down into a hierarchy of constituents that is grammatically correct (similar to dependency parsing)

{\color{lightgray}\hrule height 0.001mm}

\emph{Terminology} ---
\begin{itemize}
    \item \emph{Constituent}: Sequence of words that function as a coherent unit resp. nodes in tree
    \begin{itemize}
        \item \emph{Terminals}: Words
        \item \emph{Non-terminals}: Abstractions over words, e.g., noun phrases
    \end{itemize}
    \item \emph{Grammar}: Set of rules (productions), according to which sentences (strings) can be formed from a vocabulary
    \begin{itemize}
        \item \emph{Context-free grammar (CFG)}: Grammar where rules are applied regardless of context
    \end{itemize}
    \item \emph{Parse tree}: 
    \begin{itemize}
        \item Represents both syntactic structure of a string and its derivation under grammar
        \item Can be considered a bag of production rules and a multiset (i.e., set with repeats)
    \end{itemize}
\end{itemize}

{\color{black}\hrule height 0.001mm}

\subsection*{Context-Free Parsing}
\emph{Context-free grammar $(\mathcal{N}, \mathcal{S}, \Sigma, \mathcal{R})$} ---
\begin{itemize}
    \item Finite set of non-terminal symbols $\mathcal{N} = \{N_1, N_2, \dots\}$
    \item Distinguished start non-terminal $\mathcal{S}$
    \item Alphabet of terminal symbols $\Sigma = \{a_1, a_2, \dots\}$
    \item Set of production rules of the form $N \to \alpha$, where $N$ is non-terminal and $\alpha \in (\mathcal{N} \cup \Sigma)^*$, i.e. $\alpha$ is either terminal or non-terminal
    \item Examples:
    \begin{itemize}
        \item Language $\{a^i b^j c^k \mid i, j, k \geq 0, i + j = k\}$ is generated by:
        $
        \mathcal{S} \to a \mathcal{S} c \mid W \mid \varepsilon$
        $W \to bW \mid \varepsilon
        $
        \item Language $\{a^i b^j c^k \mid i, j, k \geq 0, i + k = j\}$ is generated by:
        $
        \mathcal{S} \to KW$
        $K \to aKb \mid \varepsilon$
        $W \to bWc \mid \varepsilon$
        \item Language $\{w \in \{a, b\}^* \mid w \textrm{ contains min. }3 a\}$ is generated by:
        $
        \mathcal{S} \to WaW aW aW$
        $W \to aW \mid ab \mid \varepsilon
        $
    \end{itemize}
\end{itemize}

{\color{lightgray}\hrule height 0.001mm}

\emph{Pumping lemma} ---
\begin{itemize}
    \item In any CFG, long enough strings have some kind of repeating structure
    \item Then, there exists a $k$ such that a string $s$ with $|s| > k$ can be written as $s = u x y z v$, where:
    \begin{itemize}
        \item $u, y, v$ are "fixed" parts, whereas $x$ and $z$ are "pumpable" parts
        \item $u x^n y z^n v$ is also in the CFG
        \item $x$ and $z$ are not empty
        \item $|x y z| < k$
    \end{itemize}\\
    Proof:
    \begin{itemize}
        \item Consider a parse tree with height $|\mathcal{V}| + 1 = N$. This tree uses all symbols in $|\mathcal{V}|$. Thus, any tree with height $> N$ must include some repetition of symbols
        \item Let $k >$ length of any string yielded by a tree with max height $N$
        \item If $|s| \geq k$, then $s$ must be yielded by a tree with height $> N$, meaning $s$ must include repetition of at least one symbol $A$
        \item From this, properties follow:
        \begin{itemize}
            \item If $T$ is the entire parse tree, $T_A$ is the parse tree with root upper $A$, and $T_{AA}$ is the parse tree with root lower $A$
            \item $T_A$ has height $\leq N$, i.e., $|xyz| < K$
            \item If $x$ and $z$ are empty (i.e., we replace $T_A$ with $T_{AA}$), we have a smaller tree that yields $s$, which is a contradiction
            \item We can extend the proof to any $n$
        \end{itemize}
    \end{itemize}
    \item Pumping lemma shows that languages that require strict equality between counts of $3+$ symbols cannot be generated by a CFG
\end{itemize}
\hl{INSERT IMAGE 1}

{\color{lightgray}\hrule height 0.001mm}

\emph{Span} ---
\begin{itemize}
    \item Contiguous segment of a sentence from word $w_i$ to $w_{j-1}$: $[i, j]$
    \item Span is admissible if it is possible to construct a parse tree, which covers exactly that span and is a valid constituent according to the grammar, i.e., there exists a non-terminal $X$ such that $X \to w[i:j]$
    \item For string of length $M$, we have:
    $
    [M, M+1)
    $ for span size $= 1$
    $
    [1, M+1)
    $ for span size $= M$
    More generally:
    $
    [M - \textrm{span size} + 1, M + 1)
    $
\end{itemize}

{\color{lightgray}\hrule height 0.001mm}

\emph{Chomsky Normal Form (CNF)} ---
\begin{itemize}
    \item CFG, where production rules follow specific structure:
    \begin{itemize}
        \item $N_1 \to N_2 N_3$ are non-terminal productions
        \item $N_- \to a_-$ are terminal productions
    \end{itemize}
    \item Prohibits cyclic rules
\end{itemize}

{\color{lightgray}\hrule height 0.001mm}

\emph{Probabilistic CFGs} ---
Motivation:
\begin{itemize}
    \item Often, multiple syntactic structures are grammatically admissible, i.e., the string is ambiguous
    \item This is the case when a non-terminal can be produced by two rules
\end{itemize}
Probabilistic CFGs $(\mathcal{N}, \mathcal{S}, \Sigma, \mathcal{R}, \mathcal{P})$:
\begin{itemize}
    \item Additionally define a set of probabilities $\mathcal{P}$ for each production rule
    \item Probabilities are locally normalized over each transition:
    $
    \sum_{k} p(N \to \alpha_k) = 1
    $
    where $N \to \alpha_1, \dots, N \to \alpha_k$ are expansions of node $N$
    \item For example:
    $
    \text{NP} \to \text{VP} (p = 0.6) \mid \text{Adj} (p = 0.4)
    $
    with total $p = 1$
    \item Then, the probability of a parse tree is the multiplication of the probabilities of the rules used to create the tree:
    $
    p(t) = \prod_{r \in t} p(r) = p(S \to S_1 S_2)^{M-1} \times p(S \to X)^M \times p(X \to Y)^M
    $
    where:
    \begin{itemize}
        \item $p(S \to S_1 S_2)^{M-1}$: repeats the rule $S \to SS$ $M-1$ times to obtain $M$ starting nodes
        \item $t$: tree
        \item $r$: rule
        \item $S$: start non-terminal
        \item $X$: non-terminal
        \item $Y$: terminal
        \item $M$: sentence length
    \end{itemize}
\end{itemize}

{\color{lightgray}\hrule height 0.001mm}

\emph{Weighted CFGs} ---
\begin{itemize}
    \item A more general formulation of PCFGs
    \item Probabilities are globally normalized over all possible parse trees
    \item Probability of a parse tree:
    $
    p(t) = \frac{1}{Z} \prod_{r \in t} \exp(\textrm{score}(r))
    $
    where:
    $
    Z = \sum_{t' \in T} \prod_{r \in t'} \exp(\textrm{score}(r))
    $
    \item Challenge: The denominator $Z(s)$ is infinitely large, potentially even larger than $\Sigma^*$ for ambiguous strings
    \item Initial solution: Probability of a parse tree, conditioned on string $s$:
    $
    p(t \mid s) = \frac{1}{Z(s)} \prod_{r \in t} \exp(\textrm{score}(r))
    $
    where:
    $
    Z = \sum_{t' \in T(s)} \prod_{r \in t'} \exp(\textrm{score}(r))
    $ 
    where $T(s)$ is set of trees that yield $s$
    \item Challenge: The denominator $Z(s)$ is still potentially infinitely large due to cyclic rules
    \item Final solution: Revert to CNF. Then, $|T(s)|$ for a string of length $M$ is the number of rooted binary trees, which is the Catalan number $C_{M-1}$
    \item With CNF, probability of a parse tree:
    $p(t \mid s) = \frac{1}{Z(s)} \prod_{N_i \to N_j N_k, \in t} \exp(\textrm{score}(N_i \to N_j N_k)) \times \prod_{N_l \to a, \in t} \exp(\textrm{score}(N_l \to a))$ where
    \begin{itemize}
        \item $Z(s) = \sum_{t' \in T(s)} \prod_{N_i \to N_j N_k, \in t'} \exp(\textrm{score}(N_i \to N_j N_k)) \times \prod_{N_l \to a, \in t'} \exp(\textrm{score}(N_l \to a))$
        \item Non-terminal productions: $\prod_{N_i \to N_j N_k, \in t} \exp(\textrm{score}(N_i \to N_j N_k))$
        \item Terminal productions: $\prod_{N_l \to a, \in t} \exp(\textrm{score}(N_l \to a))$
    \end{itemize}
    \item Can be trained via MLE with backpropagation and gradient descent
\end{itemize}

{\color{lightgray}\hrule height 0.001mm}

\emph{Cocke-Kasami-Younger (CKY) Algorithm} ---
\hl{INSERT IMAGE 2}
\begin{itemize}
    \item Tasks:
    \begin{itemize}
        \item Solve the \emph{recognition problem}: Determine if a given string is admissible by the grammar
        \item Compute the normalizing constant $Z$
        \item Find one or $k$ best syntactic parses
    \end{itemize}
    \item Requires grammar in CNF
    \item Algorithm to compute normalizing constant $Z$:
    \begin{itemize}
        \item Uses real semiring with $+, \times,0,1$
        \item Alternatively, uses log-sum-exp semiring with $\log_+, +, -\infty, 0$ where 
        $
        \log_+(x, y) = \log(e^x + e^y),
        $
    \end{itemize}
    \begin{enumerate}
        \item $N \gets |s|$
        $\textrm{chart} \gets 0$
        \item For $n = 1, \dots, N$:\\
        For $X \to S_n$ (handles single word tokens) where $X \equiv N_l$, $S_n \equiv a$ in weighted CGF:
        \begin{enumerate}
            \item If real semiring: $
            \textrm{Chart}[n, n+1, X] \mathrel{+}= \exp(\textrm{score}(X \to S_n))
            $ (weight assigned to the given rule)
            \item If log-sum-exp semiring: $
            \textrm{Chart}[n, n+1, X] = \log_+( \textrm{Chart}[n, n+1, X])
            $
        \end{enumerate}
        \item For span $= 2, \dots, N$:\\
        For $i = 1, \dots, N-\textrm{span}+1$ ($i$: beginning of span):\\
        $k \gets i + \textrm{span} - 1$ ($k$: end of span)\\
        For $j = i+1, \dots, k-1$ ($j$: breaking point of span):\\
        For $X \to Y Z$ where $X \equiv N_i$, $Y \equiv N_j$, $Z \equiv N_k$ in weighted CGF:
        \begin{enumerate}
            \item If real semiring: $\textrm{Chart}[i, k, X] \mathrel{+}= \exp(\textrm{score}(X \to Y Z)) \times \textrm{Chart}[i, j, Y] \times \textrm{Chart}[j, k, Z]$ where
            \begin{itemize}
                \item Score is weight assigned to the given rule
                \item Chart entries contains normalization factors for subtrees at $i,j$ resp. $j,k$
            \end{itemize}
            \item If log-sum-exp semiring: $
            \textrm{Chart}[i, k, X] = \log_+( \textrm{Chart}[i, k, X])
            $
        \end{enumerate}
        \item Return $\textrm{Chart}[1, N+1, \mathcal{S}]$, which contains the normalization constant
    \end{enumerate}
    \item Complexity:
    \begin{itemize}
        \item Runtime complexity: $\mathcal{O}(N^3 |\mathcal{R}|)$
        \item Space complexity: $\mathcal{O}(N^2 |\mathcal{R}|)$
        \item If, for each span length, there is only one admissible span and we know $i$ (beginning) and $j$ (breaking point), we can omit looping over $i$ and $j$ and set:
        $i = N - \textrm{span size} + 1$\\
        $j = i + 1$
        \item Then, runtime complexity: $\mathcal{O}(N |\mathcal{R}|)$
    \end{itemize}
    \item Algorithm to find best parse: Run above algorithm with $\max, +$ semiring
    \item Algorithm to find whether string is admissible by grammar: Run above algorithm with Boolean semiring
\end{itemize}